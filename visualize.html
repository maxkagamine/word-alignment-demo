<!DOCTYPE html>
<html>
<head>
<title>Alignment Visualizer</title>
<style>
body {
  font-family: sans-serif;
  font-size: 20px;
  /*background: #111;
  color: #fff;*/
}
#form {
  margin-bottom: 2em;
}
label {
  display: block;
  padding: 0.5em;
}
input {
  width: 500px;
  /*background: #111;
  color: inherit;
  border: 1px solid #ccc;*/
  font-size: inherit;
}
svg {
  width: 100%;
}
#download {
  display: inline-block;
  margin-top: 2em;
}
</style>
</head>
<body>

  <div id="form">
    <label>From text: <input id="fromTextInput" value="瑞鳳です。軽空母ですが、練度が上がれば、正規空母並の活躍をお見せできます。" /></label>
    <label>To text: <input id="toTextInput" value="I'm Zuihou. Even though I'm a light carrier, I can show you that I'll be as good as standard carriers with some experience." /></label>
    <label>Alignment result: <input id="alignmentResultInput" value="0,2,4,10,2,4,0,3,4,5,10,11,5,6,30,35,6,8,36,43,8,10,25,27,10,11,12,23,11,12,43,44,15,18,73,80,18,19,70,72,20,22,84,92,22,24,93,101,25,26,73,83,26,28,112,122,29,30,102,106,30,32,51,59,32,34,47,50,34,36,47,50,36,37,122,123" /></label>
  </div>

  <div id="output"></div>

  <a id="download" href="#" hidden download="alignment.svg">Download</a>

  <script>
    const EM = 30;
    const TEXT_SPACING = 7 * EM;
    const LINE_SPACING = 0.33 * EM;

    // Offsets where the lines *appear* to start/end (or actually do, if
    // LINE_SPACING is set to 0) to bring it closer to the actual text.
    const LINE_ORIGIN_OFFSET = 0.3 * EM;

    const FROM_TEXT_ID = 'fromText';
    const TO_TEXT_ID = 'toText';

    const fromTextInput = document.getElementById('fromTextInput');
    const toTextInput = document.getElementById('toTextInput');
    const alignmentResultInput = document.getElementById('alignmentResultInput');
    const outputEl = document.getElementById('output');
    const dlLink = document.getElementById('download');

    fromTextInput.addEventListener('input', render);
    toTextInput.addEventListener('input', render);
    alignmentResultInput.addEventListener('input', render);
    render();

    dlLink.addEventListener('click', () => {
      const svg = document.querySelector('#output svg');
      const blob = new Blob([createDownloadableSvg(svg)], { type: 'text/svg' });
      dlLink.href = URL.createObjectURL(blob);
    });

    function render() {
      const fromText = fromTextInput.value;
      const toText = toTextInput.value;
      const alignmentResult = parseAlignmentResult(alignmentResultInput.value);

      console.log('fromText =', fromText, ', toText =', toText, ', alignmentResult =', alignmentResult);

      outputEl.innerHTML = '';

      if (!fromText || !toText || !alignmentResult.length) {
        return;
      }

      const svg = createSvgElement('svg');
      svg.setAttribute('version', '1.1');
      svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      svg.setAttribute('viewBox', '0 0 10000 5000'); // For some reason Chrome doesn't calculate off-screen text's bbox correctly.
      outputEl.appendChild(svg);

      const style = createSvgElement('style');
      style.innerHTML = `
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap');
text {
  font-family: 'Noto Sans JP', sans-serif;
  font-size: ${EM}px;
}
      `;
      svg.appendChild(style);

      const fromTextEl = createTextElement(fromText, FROM_TEXT_ID, { x: 0, y: 0 });
      const toTextEl = createTextElement(toText, TO_TEXT_ID, { x: 0, y: TEXT_SPACING });
      svg.appendChild(fromTextEl);
      svg.appendChild(toTextEl);

      centerHorizontally(fromTextEl, toTextEl);

      for (const { fromStart, fromEnd, toStart, toEnd } of alignmentResult) {
        const from = fromText.substr(fromStart, fromEnd - fromStart);
        const to = toText.substr(toStart, toEnd - toStart);

        if (!/\p{L}/u.test(from) && !/\p{L}/u.test(to)) {
          console.log(`Skipping alignment of punctuation/symbol: ${from} (${fromStart}) => ${to} (${toStart})`);
          continue;
        }

        console.log(`Drawing alignment for ${from} (${fromStart}) => ${to} (${toStart})`);
        drawAlignment(svg, fromStart, fromEnd, toStart, toEnd);
      }

      setViewBox(svg);
      setTimeout(() => setViewBox(svg), 10); // Hack
      setTimeout(() => setViewBox(svg), 100); // Hack
      setTimeout(() => setViewBox(svg), 1000); // Hackity hack

      dlLink.removeAttribute('hidden');
    }

    /** @returns {SVGElement} */
    function createSvgElement(tagName) {
      return document.createElementNS('http://www.w3.org/2000/svg', tagName);
    }

    function parseAlignmentResult(alignmentResultStr) {
      const numbers = alignmentResultStr.split(',').map(x => parseInt(x));
      if (numbers.length % 4 != 0 || numbers.some(isNaN)) {
        return [];
      }
      const result = [];
      for (let i = 0; i < numbers.length; i += 4) {
        result.push({
          fromStart: numbers[i],
          fromEnd: numbers[i + 1],
          toStart: numbers[i + 2],
          toEnd: numbers[i + 3],
        });
      }
      console.log('alignment result =', result);
      return result;
    }

    function createTextElement(str, id, attrs = {}) {
      const text = createSvgElement('text');
      text.id = id;
      text.setAttribute('text-anchor', 'start');
      text.setAttribute('dominant-baseline', 'hanging');

      for (let [attr, value] of Object.entries(attrs)) {
        text.setAttribute(attr, value);
      }

      for (let i = 0; i < str.length; i++) {
        const tspan = createSvgElement('tspan');
        tspan.textContent = str[i];
        tspan.id = id + i;

        text.appendChild(tspan);
      }

      return text;
    }

    function centerHorizontally(el1, el2) {
      const box1 = el1.getBBox();
      const box2 = el2.getBBox();
      if (box1.width > box2.width) {
        el2.setAttribute('x', (box1.width - box2.width) / 2);
      } else if (box2.width > box1.width) {
        el1.setAttribute('x', (box2.width - box1.width) / 2);
      }
    }

    function setViewBox(svg) {
      const size = Array.from(svg.children).reduce((size, el) => {
        if ('getBBox' in el) {
          const bbox = el.getBBox();
          size.width = Math.max(size.width, Math.ceil(bbox.x + bbox.width));
          size.height = Math.max(size.height, Math.ceil(bbox.y + bbox.height));
        }
        return size;
      }, { width: 0, height: 0 });
      svg.setAttribute('viewBox', `0 0 ${size.width} ${size.height}`);
    }

    function getCharacterRangeRect(svg, textId, start, end) {
      const startBox = svg.getElementById(textId + start)?.getBBox();
      const endBox = svg.getElementById(textId + (end - 1))?.getBBox();

      if (!startBox) {
        console.error(`Missing element #${textId + start} (alignment doesn't match text?).`);
      }
      if (!endBox) {
        console.error(`Missing element #${textId + (end - 1)} (alignment doesn't match text?).`);
      }

      return {
        top: Math.min(startBox.y, endBox.y),
        left: Math.min(startBox.x, endBox.x),
        right: Math.max(startBox.x + startBox.width, endBox.x + endBox.width),
        bottom: Math.max(startBox.y + startBox.height, endBox.y + endBox.height),
        get width() {
          return this.right - this.left;
        },
        get height() {
          return this.bottom - this.top;
        }
      };
    }

    /**
     * Because there's a gap between the text and the line (LINE_SPACING +/- the
     * offsets), the x position of both ends of the line need to be offset, so
     * as to "crop" the line and make it seem it continues to the correct spot
     * in the text.
     *
     * Returns the offset for the top point. Invert for the bottom point.
     */
    function calculateXOffset(x1, x2) {
      const totalTextSpacing = TEXT_SPACING + (LINE_ORIGIN_OFFSET * 2)
      return (LINE_SPACING / totalTextSpacing) * Math.abs(x1 - x2) * (x1 > x2 ? -1 : 1);
    }

    function drawAlignment(svg, fromStart, fromEnd, toStart, toEnd) {
      const fromRect = getCharacterRangeRect(svg, FROM_TEXT_ID, fromStart, fromEnd);
      const toRect = getCharacterRangeRect(svg, TO_TEXT_ID, toStart, toEnd);

      let x1 = fromRect.left + (fromRect.width / 2);
      let x2 = toRect.left + (toRect.width / 2);
      let xOffset = calculateXOffset(x1, x2);
      x1 += xOffset;
      x2 -= xOffset;

      const line = createSvgElement('line');
      line.setAttribute('x1', x1);
      line.setAttribute('y1', fromRect.bottom + LINE_SPACING - LINE_ORIGIN_OFFSET);
      line.setAttribute('x2', x2);
      line.setAttribute('y2', toRect.top - LINE_SPACING + LINE_ORIGIN_OFFSET);
      line.setAttribute('stroke', 'black');
      line.setAttribute('stroke-width', '2');

      svg.appendChild(line);
    }

    function createDownloadableSvg(svg) {
      svg = svg.cloneNode(true);
      for (let el of svg.querySelectorAll('[id]')) {
        el.removeAttribute('id');
      }
      for (let text of svg.querySelectorAll('text')) {
        text.innerHTML = text.textContent;
      }
      return '<?xml version="1.0" standalone="yes"?>\n' + svg.outerHTML;
    }
  </script>

</body>
</html>
